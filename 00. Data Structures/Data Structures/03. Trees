#!/bin/python3

# 01. Tree: Preorder Traversal
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)
"""


def preOrder(root):
    print root.data,
    if root.left is not None:
        preOrder(root.left)
    if root.right is not None:
        preOrder(root.right)
        

# 02. Tree: Postorder Traversal
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)
"""
def postOrder(root):
    if root is not None:
        postOrder(root.left)
        postOrder(root.right)
        print root.data,



# 03. Tree: Inorder Traversal
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)
"""
def inOrder(root):
    if root is not None:
        inOrder(root.left)
        print root.data,
        inOrder(root.right)



# 04. Tree: Height of a Binary Tree
# Enter your code here. Read input from STDIN. Print output to STDOUT
'''
class Node:
      def __init__(self,info): 
          self.info = info  
          self.left = None  
          self.right = None 
           
       // this is a node of the tree , which contains info as data, left , right
'''
def height(root):
    if root is not None:
        return max(1 + height(root.left), 1 + height(root.right))
    else:
        return -1
    

# 05. Tree : Top View
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)"""

def _topLeft(root):
    if root is not None:
        _topLeft(root.left)
        print root.data,

def _topRight(root):
    if root is not None:
        print root.data,
        _topRight(root.right)

def topView(root):
    _topLeft(root.left)
    print root.data,
    _topRight(root.right)
        

# 06. Tree: Level Order Traversal
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)
"""

def height(root):
    if root is not None:
        return max(1 + height(root.left), 1 + height(root.right))
    else:
        return -1

def _levelOrder(root, level):
    if root is not None:
        if level == 0:
            print root.data,
        else:
            _levelOrder(root.left, level - 1)
            _levelOrder(root.right, level - 1)
        

def levelOrder(root):
    for level in range(height(root)+1):
        _levelOrder(root, level)
        

# 07. Binary Search Tree : Insertion
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)"""

def insert(root, val):
    if root is None:
        root = Node(data=val)
        return root
    
    current = root
    while True:
        if current.data > val:
            if current.left is not None:
                current = current.left
            else:
                current.left = Node(data=val)
                break
        else:
            if current.right is not None:
                current = current.right
            else:
                current.right = Node(data=val)
                break
    
    return root
    

# 08. Binary Search Tree : Lowest Common Ancestor
"""
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.data (the value of the node)
"""

def lca(root , v1 , v2):
    vals = sorted([v1, v2])
    v1, v2 = vals[0], vals[1]
    node = root
    while True:
        if v1 < v2 < node.data:
            node = node.left
        if v1 > v2 > node.data:
            node = node.right
        if v1 <= node.data <= v2:
            break
    return node
        

# 09. Tree: Huffman Decoding
"""class Node:
    def __init__(self, freq,data):
        self.freq= freq
        self.data=data
        self.left = None
        self.right = None
"""        

# Enter your code here. Read input from STDIN. Print output to STDOUT
def is_leaf(root):
    if root.right == None and root.left == None:
        return True
    else:
        return False
    
def decodeHuff(root , s):
    node = root
    output = ''
    for dig in s:
        #print "dig = {} node.freq = {}".format(dig, node.freq)
        if dig == '0':
            if is_leaf(node.left):
                output += node.left.data
                node = root
            else:
                node = node.left
        else:
            if is_leaf(node.right):
                output += node.right.data
                node = root
            else:
                node = node.right
    
    print output
        
        

# 10. Swap Nodes [Algo]
#!/usr/bin/env python3
import sys 

class Node():
    def __init__(self, left=None, right=None, data=None):
        self.left = left
        self.right = right
        self.data = data
        
def find_node_recursive(root, data):
    if root is not None:
        res = None
        if root.data == data:
            res = root
        if res == None:
            res = find_node(root.left, data)
        if res == None:
            res = find_node(root.right, data)
        return res

def find_node(root, data):
    current = root 
    s = []
    done = 0
     
    while(not done):
        if current is not None:
            s.append(current)
            current = current.left 
        else:
            if(len(s) > 0):
                current = s.pop()
                if current.data == data:
                    return current
         
                current = current.right 
            else:
                done = 1
    return None

def height(root):
    if root is not None:
        return max(1 + height(root.left), 1 + height(root.right))
    else:
        return 0
    
def inOrder(root):
    if root is not None:
        inOrder(root.left)
        print("{} ".format(root.data), end='')
        inOrder(root.right)
        
def swap_level(root, level):
    if root is not None:
        if level == 1:
            root = swap_subtrees(root)
        else:
            swap_level(root.left, level - 1)
            swap_level(root.right, level - 1)
            
def swap_subtrees(node):
    node.left, node.right = node.right, node.left
    return node
            
if __name__ == "__main__":
    sys.setrecursionlimit(15000)
    root = Node(data = 1)
    node = root
    n = int(input().strip())

    for ind in range(1, n+1):
        a, b = map(int,input().split(' '))
        #inOrder(root)
        #print()
        #print("ind = {} a = {} b = {}".format(ind, a, b))
        
        node = find_node(root, ind)
        
        if a != -1:
            node.left = Node(data = a)
        if b != -1:
            node.right = Node(data = b)
            
    t = int(input().strip())
    for ind in range(t):
        k = int(input().strip())
        #print("k = {}".format(k))
        
        for level in range(k, height(root)+1, k):
            swap_level(root, level)
        inOrder(root)
        print()
            

# 11. Is This a Binary Search Tree?
""" Node is defined as
class node:
  def __init__(self, data):
      self.data = data
      self.left = None
      self.right = None
"""
def inOrder(root):
    if root is not None:
        out = []
        out += inOrder(root.left)
        out.append(root.data)
        #print(root.data, end=' ')
        out += inOrder(root.right)
        return out
    else:
        return [] 
        
def check_binary_search_tree_(root):
    get_ordered = inOrder(root)
    return get_ordered == sorted(list(set(get_ordered)))

    


