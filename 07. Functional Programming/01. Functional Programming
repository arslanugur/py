# Functional programming is a style of programming that (as the name suggests) is based around functions.
# A key part of functional programming is higher-order functions. 
# We have seen this idea briefly in the previous lesson on functions as objects. 
# Higher-order functions take other functions as arguments, or return them as results.
# Example:
def apply_twice(func, arg):
    return func(func(arg))

def add_five(x):
    return x + 5

print(apply_twice(add_five, 10))  # 20

# The function apply_twice takes another function as its argument, and calls it twice inside its body.


# Understanding this problem requires a basic understanding of an algebraic concept called "composition of functions." 
# Think back to algebra class in high school where you had to evaluate f(g(3)). 
# You first need to evaluate the inner function g, with an input of 3. 
# The output/result of g(3) becomes the input of the outer function f. 
# i.e. given f(x) = x + 2 and g(x) = 2x - 1 evaluate f(g(3)) 
# First, evaluate g(3). g(3) = 2(3) - 1 g(3) = 6 - 1 g(3) = 5 
# Second, take the result/output of g(3) which is 5, and plug it into the outer function f. 
# f(5) = (5) + 2 f(5) = 7 
# Thus, f(g(3)) = 7 Using that same understanding of composition of functions reconsider the problem below (I added line numbers). 
# 1. def apply_twice(func, arg): 
# 2. return func(func(arg)) 
# 3. 4. def add_five(x): 
# 5. return x + 5 
# 6. 7. print(apply_twice(add_five, 10)) 

# We have to work backwards to understand this. 
# On line 7, we are calling the function “apply_twice”, which has two arguments: a call to another function ”add_five” and the number 10. 
# Now jump to line 1. It becomes “ def apply_twice(add_five,10). 
# Line 2 becomes “return func(add_five,10)” 
# Since a function is within the parentheses, right away we jump to another function, add_five, on line 4. 
# This becomes “def add_five(10):” Line 5 becomes “return 10+5”. 
# So now we have the value of 15. Jumping back to line 2, we have “return func(15)”, which becomes “add_five(15)”. 
# We jump back to Line 4 and it becomes “def add_five(15):”, and line 5 becomes “return 15+5”, or 20. 
# So line 2 returns 20, which becomes the value of line 1, which is printed in line 7.

# In line 1 and 2 as per given example, here, func = add_five arg = 10 
# Let's consider the line 4 and 5, according to the function, 
# when u define the argument 'x', it will be added to 5; add_five = x+5 
# so, def apply_twice(add_five, 10) return add_five(add_five(10)) 
# calculating line 2 as per example add_five(add_five(10)) =5 + (5 + 10) =5 + 15 =20 so the answer is 20


# Here "func" is actually add_five (x) as it's put as an argument when apply_twice () is called in print (). 
# The second argument "arg" is replaced with an integer "10" in apply_twice (). 
# Now add_five () wich adds "5" to value of its argument. 
# Well , it gets argument in the following block; that's the 1st block in our code. 
# def apply_twice (func, arg): Return func (func (arg)) This block makes 10 as argument for add_five () as func is actually add_five (). 
# Our *print* statement "print (apply_twice(add_five, 10))" replaces func with add_five (). 
# Now See "return func (func (arg))" Here "arg" is replaced with 10 and func (add_five) adds five , you will get 15. 5 is added again to 15 . Result is 20.
# "return func (func (arg))"
# func (add_five (10))
# func (15)
# add_five (15) # 20 

# Example:
def test(func, arg):
  return func(func(arg))

def mult(x):
  return x * x

print(test(mult, 2))  # 16





    
