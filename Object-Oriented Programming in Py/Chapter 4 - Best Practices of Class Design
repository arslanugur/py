4.  Best Practices of Class Design
"""How do you design classes for inheritance? Does Python have private attributes? Is it possible to control attribute access? 
You'll find answers to these questions (and more) as you learn class design best practices."""

4.1. Designing for inheritance and polymorphism
1. Designing for inheritance and polymorphism
In this final chapter, we'll talk about some good practices of class design. 
We'll cover two main topics: efficient use of inheritance, and managing the levels of access to the data contained in your objects.

2. Polymorphism
Polymorphism means using a unified interface to operate on objects of different classes. We've already dealt with it in Chapter 2.

3. Account classes
We defined a bank account class, and two classes inherited from it: a checking account class and a savings account class. 
All of them had a withdraw method, but the checking account's method was executing different code.

4. All that matters is the interface
Let's say we defined a function to withdraw the same amount of money from a whole list of accounts at once. 
This function doesn't know -- or care -- whether the objects passed to it are checking accounts, 
savings accounts or a mix -- all that matters is that they have a withdraw method that accepts one argument. 
That is enough to make the function work. It does not check which withdraw it should call -- the original or the modified. 
When the withdraw method is actually called, 
Python will dynamically pull the correct method: 
modified withdraw for whenever a checking account is being processed,and base withdraw for whenever a savings 
or generic bank account is processed. So you, as a person writing this batch processing function, 
don't need to worry about what exactly is being passed to it, only what kind of interface it has. 
To really make use of this idea, you have to design your classes with inheritance and polymorphism - the uniformity of interface - in mind

5. Liskov substitution principle
There is a fundamental object-oriented design principle of when and how to use inheritance properly, 
called "Liskov substitution principle" named after the computer scientist Barbara Liskov: 
A base class should be interchangeable with any of its subclasses without altering any properties of the surrounding program. 
Using the example of our Account hierarchy, that means that wherever in your application you use a bankaccount object instance, 
substituting a checking account instead should not affect anything in the surrounding program. 
For example, the batch withdraw function worked regardless of what kind of account was used.

6. Liskov substitution principle
This should be true both syntactically and semantically. 
On the one hand, 
the method in a subclass should have a signature with parameters and returned values compatible with the method in the parent class. 
On the other hand, 
the state of objects also must stay consistent; 
the subclass method shouldn't rely on stronger input conditions, should not provide weaker output conditions, 
it should not throw additional exceptions and so on.

7. Violating LSP
Let's illustrate some possible violations of LSP - 
Liskov substitution principle - on our account classes: for example, the parent's -- or base's -- withdraw method could require 1 parameter, 
but the subclass method could require 2. Then we couldn't use the subclass's withdraw in place of the parent's.
But if the subclass method has a default value for the second parameter, then there is no problem. 
If the subclass method only accepts certain amounts, unlike the base one, 
then sometimes the subclass could not be used in place of the base class, if those unsuitable amounts are used. 
If the base withdraw had a check for whether the resulting balance is positive, and only performed the withdrawal in that case, 
but the subclass did not do that, we wouldn't be able to use subclass in place of the base class, 
because it's possible that ambient program depends on the fact that the balance is always positive after withdrawal.

8. Violating LSP
There are other ways to violate LSP like changing attributes that weren't changed in the base class, or throwing additional exceptions 
that the base class didn't throw (because those new exceptions are guaranteed to be unhandled).

9. No LSP - no inheritance
The ultimate rule is that if your class hierarchy violates the Liskov substitution principle, then you should not be using inheritance, 
because it is likely to cause the code to behave in unpredictable ways somewhere down the road.

4.2. Polymorphic methods
To design classes effectively, you need to understand how inheritance and polymorphism work together.

In this exercise, you have three classes - one parent and two children - each of which has a talk() method. Analyze the following code:
class Parent:
    def talk(self):
        print("Parent talking!")     

class Child(Parent):
    def talk(self):
        print("Child talking!")          

class TalkativeChild(Parent):
    def talk(self):
        print("TalkativeChild talking!")
        Parent.talk(self)


p, c, tc = Parent(), Child(), TalkativeChild()

for obj in (p, c, tc):
    obj.talk()class Parent:
    def talk(self):
        print("Parent talking!")     

class Child(Parent):
    def talk(self):
        print("Child talking!")          

class TalkativeChild(Parent):
    def talk(self):
        print("TalkativeChild talking!")
        Parent.talk(self)


p, c, tc = Parent(), Child(), TalkativeChild()

for obj in (p, c, tc):
    obj.talk()
    
What is the output of the code above?
Parent talking!
Child talking!
Talkative Child talking!
Parent talking!

Polymorphism ensures that the exact method called is determined dynamically based on the instance. 
What do you think would happen if Child did not implement talk()?

4.3. Square and rectangle
The classic example of a problem that violates the Liskov Substitution Principle is "the Circle-Ellipse problem", 
sometimes called the Square-Rectangle problem.

By all means, it seems like you should be able to define a class Rectangle, with attributes h and w (for height and width), 
and then define a class Square that inherits from the Rectangle. After all, a square "is-a" rectangle!

Unfortunately, this intuition doesn't apply to object-oriented design.

Instructions 1/4
Create a class Rectangle with a constructor that accepts two parameters, h and w, and sets its h and w attributes to the values of h and w.
Create a class Square inherited from Rectangle with a constructor that accepts one parameter w, 
and sets both the h and w attributes to the value of w.

Hint
There's nothing tricky in this exercise, so if you're having problems, check the usual suspects: are you using self? 
Correct punctuation? Correct number of parameters and correct attribute names?

Code:
# Define a Rectangle class
class Rectangle:
    def __init__(self, h, w):
      self.h, self.w = h, w

# Define a Square class
class Square(Rectangle):
    def __init__(self, w):
      self.h, self.w = w, w  
      
Instructions 2/4
Question: The classes are defined for you. Experiment with them in the console.

For example, in the console or the script pane, create a Square object with side length 4. Then try assigning 7 to the h attribute.

What went wrong with these classes?
---> The 4x4 Square object would no longer be a square if we assign 7 to h.

Instructions 3/4
A Square inherited from a Rectangle will always have both the h and w attributes, but we can't allow them to change independently of each other.
-Define methods set_h() and set_w() in Rectangle, each accepting one parameter and setting h and w.
-Define methods set_h() and set_w() in Square, each accepting one parameter, and setting both h and w to that parameter in both methods.

Hint
A template method is provided for each class: just replace h with w!
Be careful with parameter names, especially when copy-pasting: make sure you really mean h or w when you're using them!

Code:
class Rectangle:
    def __init__(self, w,h):
      self.w, self.h = w,h
      
# Define set_h to set h       
    def set_h(self, h):
      self.h = h

# Define set_w to set w
    def set_w(self, w):
      self.w = w   
      
class Square(Rectangle):
    def __init__(self, w):
      self.w, self.h = w, w 
      
# Define set_h to set w and h 
    def set_h(self, h):
      self.h = h
      self.w = h
      
# Define set_w to set w and h 
    def set_w(self, w):
      self.w = w   
      self.h = w  
      
Instructions 4/4
Question
Later in this chapter you'll learn how to make these setter methods run automatically when attributes are assigned new values, 
don't worry about that for now, just assume that when we assign a value to h of a square, now the w attribute will be changed accordingly.

How does using these setter methods violate Liskov Substitution principle?
---> Each of the setter methods of Square change both h and w attributes, while setter methods of Rectangle change only one attribute at a time, 
so the Square objects cannot be substituted for Rectangle into programs that rely on one attribute staying constant.
Remember that the substitution principle requires the substitution to preserve the oversall state of the program. 
An example of a program that would fail when this substitution is made is a unit test for a setter functions in Rectangle class.


4.4. Managing data access: private attributes
Got It!
1. Managing data access: private attributes
In the next two lessons, we'll talk about managing data access.

2. All class data is public
All class data in Python is technically public. Any attribute or method of any class can be accessed by anyone. 
If you are coming from a background in another programming language like Java, this might seem unusual or an oversight, but it is by design. 
The fundamental principle behind much of Python design "we are all adults here". 
It is a philosophy that goes beyond just code, and describes how the Py community interacts with each other: u should ve trust in ur fellow developers.

3. Restricting access
That said, there are a few ways to manage access to data. 
We can use some universal naming conventions to signal that the data is not for external consumption; 
then, there are special kinds of attributes called properties that allow you to control how each attribute is modified. 
Finally, there are special methods that you can override to change how attributes are used entirely. 
We'll cover the first two options in this chapter, and you are unlikely to ever need anything beyond that.

4. Naming convention: internal attributes
Let's start with naming conventions. 
The first and most important convention is using a single leading underscore to indicate an attribute 
or method that isn't a part of the public class interface, and can change without notice. 
This convention is widely accepted among Python developers, so you should follow it both as a class developer and as a class user. 
Nothing is technically preventing you from using these attributes, 
but a single leading underscore is the developer's way of saying that you shouldn't. 
The class developer trusts that you are an adult and will be able to use the class responsibly. 
This convention is used for internal implementation details and helper functions. 
For example, a pandas DataFrame has an underscore-is_mixed_type attribute that indicates whether the DataFrame contains data of mixed types, 
and the datetime module contains a _ymd2ord function 
that converts a date into a number containing how many days have passed since January 1st of year 1.

5. Naming convention: pseudoprivate attributes
Another naming convention is using a leading double underscore. 
Attributes and methods whose names start with a double underscore are the closest thing Python has to "private" fields 
and methods of other programming languages. 
In this case, it means that this data is not inherited - at least, not in a way you're used to, because Python implements name mangling: 
any name starting with a double underscore will be automatically prepended by the name of the class when interpreted by Python, 
and that new name will be the actual internal name of the attribute or method. 
The main use of these pseudo-private attributes is to prevent name clashes in child classes: 
you can't control what attributes or methods someone will introduce when inheriting from your class, 
and it's possible that someone will unknowingly introduce a name that already exists in you class, thus overriding the parent method or attribute! 
You can use double leading underscores to protect important attributes and methods that should not be overridden. 
Finally, be careful: leading AND trailing double underscores are only used for build-in Python methods like init, 
so your name should only start -- but not end! -- with double underscores.

4.5. Attribute naming conventions
In Python, all data is public. Instead of access modifiers common in languages 
like Java, Python uses naming conventions to communicate the developer's intention to class users, 
shifting the responsibility of safe class use onto the class user.

Python uses underscores extensively to signal the purpose of methods and attributes. 
In this exercise, you will match a use case with the appropriate naming convention.

Instructions
Drag the cards into the bucket representing the most appropriate naming convention for the use case.
_name    - a helper method that checks validity of an attribute's value but isn't considered a part of class's public interface
__name   - A 'version' attribute that stores the current version of the class and shouldn't be passed to child classes, who ill have their own versions.
__name__ - A method that is run whenever the object is printed

The single leading underscore is a convention for internal details of implementation. 
Double leading underscores are used for attributes that should not be inherited to aviod name clashes in child classes. 
Finally, leading and trailing double underscores are reserved for built-in methods.

4.6. Using internal attibutes
4.7. Properties
4.8. What do properties do?
4.9. Create and set properties
4.10. Read-only properties
4.11. Congratulations!
